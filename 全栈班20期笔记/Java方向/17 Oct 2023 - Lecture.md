# 17 Oct 2023 - Lecture
##  Java第九课 JVM基础

- Java字节码解析
    Java字节码解析是指分析和理解Java字节码文件的过程。Java字节码是一种中间表示形式，它包含了Java程序的指令集和结构信息，而不依赖于特定硬件或操作系统。这使得Java字节码可以在不同平台上执行，因为它们首先由Java虚拟机（JVM）执行，JVM将字节码转换为本机机器码。

    Java字节码解析通常涉及以下方面：

    - 字节码文件分析： 这包括读取字节码文件（通常以.class文件为扩展名），分析文件结构，了解类、方法、字段以及其属性的布局和组织。

    - 指令解析： 解析字节码文件中的指令，包括操作码（opcode）和操作数。操作码定义了执行的操作，而操作数提供了操作所需的数据。

    - 符号表处理： 在解析字节码时，需要处理符号表，将符号引用解析为实际引用对象，如类、方法、字段等。

    - 控制流分析： 分析控制流结构，确定方法的入口点、出口点以及异常处理程序。

    - 类型检查和验证： 在某些情况下，Java字节码解析可能涉及类型检查和验证，以确保字节码文件符合Java语言规范。

    Java字节码解析通常由开发工具、编译器、调试器和字节码操纵库等工具使用。这些工具可以用于分析、修改和生成Java字节码，或者用于在运行时对字节码进行检查和验证。字节码解析对于Java虚拟机、代码分析、反编译、性能优化以及某些安全性任务非常重要。它允许开发人员更深入地理解Java程序的内部结构和行为。
    Java字节码文件结构
    
![Java字节码文件结构](assets/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png)
- 类加载
    类加载是Java虚拟机（JVM）在运行Java程序时将字节码文件（.class文件）加载到内存中并准备执行的过程。这个过程涉及将Java类的字节码文件加载到JVM的方法区或元空间中，并进行一系列的准备、连接、初始化等操作。

    类加载过程通常分为以下几个阶段：

    - 加载（Loading）： 在这个阶段，JVM通过类加载器（ClassLoader）查找并加载字节码文件。这可以是来自本地文件系统、网络资源或其他来源的.class文件。加载后，类的字节码被存储在内存中。

    - 连接（Linking）： 连接阶段进一步分为三个步骤：

        - 验证（Verification）：验证确保字节码文件的结构和语义是正确的，以防止恶意代码或错误代码的执行。
        - 准备（Preparation）：在这个步骤中，类的静态成员变量被分配内存并初始化为默认值，如零值（0、false、null等）。
        - 解析（Resolution）：解析是指将符号引用转化为直接引用，确保类和方法可以正确链接。

    - 初始化（Initialization）： 在初始化阶段，类的静态初始化块（静态构造器）和静态成员变量被初始化，这是类加载过程中的最后一个阶段。初始化可以包括执行Java类中的静态初始化块以及调用静态成员变量的初始化赋值。

- Java内存结构
    - 线程私有： 栈，程序计数器
    - 线程共享： 堆，方法区
    - 垃圾回收（GC）
    - 新生代，老年代（Young Gen， Old Gen）
        - new对象进入伊甸园（Eden）
        - 幸存者0和幸存者1
        - 进入老年时代
![Java内存结构](assets/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png)
![Java内存结构-全](assets/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-%E5%85%A8.png)

- Java内存模型
    Java内存模型（Java Memory Model，简称JMM）是一种规范，它定义了多线程程序中共享内存的行为，以确保多线程程序在不同的计算机体系结构和操作系统上都能以可预测的方式运行。JMM定义了线程之间如何共享数据以及如何保证共享数据的可见性和一致性。关键概念和规则在Java内存模型中包括：

    - **主内存（Main Memory）**： 主内存是所有线程共享的内存，其中存储了所有的共享变量。

    - **工作内存（Working Memory）**： 每个线程都有自己的工作内存，用于存储主内存中的共享变量的副本。线程只能直接操作自己的工作内存中的数据。

    - **可见性（Visibility）**： Java内存模型确保一个线程对共享变量的修改对其他线程是可见的。这是通过使用volatile关键字和synchronized关键字等手段来实现的。

    - **原子性（Atomicity）**： Java内存模型保证特定操作是原子的，即要么完全执行，要么不执行。这是通过使用synchronized关键字或java.util.concurrent包中的原子类来实现的。

    - **有序性（Ordering）**： Java内存模型定义了一组规则，确保在不同线程中执行的操作的顺序不会与源代码中的顺序发生颠倒。这有助于避免数据竞争和数据不一致性。

    Java内存模型的主要目标是提供一种规范，以便开发人员可以编写多线程程序而无需担心不同的硬件和操作系统如何处理内存。它定义了一组规则和约定，以确保多线程程序在各种情况下的一致性和可靠性。 Java提供的`synchronized`关键字、`volatile`关键字以及`java.util.concurrent`包中的工具都是为了帮助开发人员遵循Java内存模型规则，从而编写线程安全的程序。
